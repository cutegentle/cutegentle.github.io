<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Laravel OAuth 2.0 X YouTube X bilibili</title>
    <link href="/2021/12/12/Laravel-OAuth-2-0-X-YouTube-X-bilibili/"/>
    <url>/2021/12/12/Laravel-OAuth-2-0-X-YouTube-X-bilibili/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Laravel-OAuth-2-0-X-YouTube-X-bilibili"><a href="#Laravel-OAuth-2-0-X-YouTube-X-bilibili" class="headerlink" title="Laravel OAuth 2.0  X YouTube X bilibili"></a>Laravel OAuth 2.0  X YouTube X bilibili</h4><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前几天突然手机微信出现了条YouTube视频链接。如下：</p><p><a href="https://www.youtube.com/watch?v=oJCImQWfCCM&amp;list=PLC-R40l2hJfdyfZ3jkDKOcyoqmIgw2wda&amp;index=2">https://www.youtube.com/watch?v=oJCImQWfCCM&amp;list=PLC-R40l2hJfdyfZ3jkDKOcyoqmIgw2wda&amp;index=2</a></p><p>打开一看，Build OAuth 2.0 SSO with PHP (Laravel 8)。近期一直在折腾基于php实现SSO，就点进去学习一波。</p><h4 id="学习见解"><a href="#学习见解" class="headerlink" title="学习见解"></a>学习见解</h4><p>看到第四个视频，结合相关知识自己理解了一下：</p><p>实际上就是laravel8中的官方扩展包，passport oauth里面的教程，采用的是OAuth2.0的授权码模式接下来我将做一些精华的笔记（废话+大白话）。实际上就是 <a href="https://www.bilibili.com/video/BV1ME411q7NA?p=8">https://www.bilibili.com/video/BV1ME411q7NA?p=8</a> 印度版。。。（话说印度人挺好学的，就是口音太xxxx）<br>注意在生产环境下（不要采用视频的全写在路由，而是要像YouTube中的写在专门的控制器下，route要简洁！）lishen的视频讲的不错，实际上laravel是可以提供oauth服务的。在纯净版的环境下，serve端就是类似于微信授权。我们自己起来的client端相当于是第三方app（可以是bilibili），在bilibli弄个login，上面附有微信登入连接，连接则路由到我们的serve端的login，serve首先要login也就是（常见的点击确定微信登入），登入后就会到oaut/authorize也就是passport注册路由，那么会出现是否授权的页面（也就是确定微信登入后的是否授权）授权了url参数auth/callback+code+state ;如果按了取消没有授权就是error+state。他自己写了一个callback的相应页面来进行成功授权是否的不同逻辑。可以弹出拒接的框等。点击授权后会报错因为没有写get/token这个应该是laravel他自己csrf什么的问题，这个照抄文档就可以。主要问题在于laravel这种客户端要手动授权。。client 以及他的密码。</p><h4 id="另："><a href="#另：" class="headerlink" title="另："></a>另：</h4><p>Laravel Jetstream 除了提供基于浏览器的 Cookie 认证外，还内置集成了 Laravel Sanctum 提供 API 令牌认证。现在主要的问题在于，jetstream套件本身深不可测，自带sanctum，我现在又要使用passport这个api认证，理论上讲是没有问题，但是能否接入，问题还是很大的，而且目前市面上没有提供api认证后的退出demo，accesstoken也不是很全。而且我只能选择passport只有它能够提供oauth，这样一来要弃用jetstream中的sanctum，有得要重新搞懂内嵌在jetstream中sanctum，将其弃用转用passport这是个很大的问题。具体实现来说，复制一个mauth当做测试按照lishen的来进行安装passport看看会不会冲突，实际上只要mauth正常运行，新起一个客户端就是小问题。注意要好好看youtube上面新建的项目实际上就是lishen的，好好看看数据库里面字段的变化，测试环境需要把mauth的脚本先保存。</p><h4 id="深入学习链接"><a href="#深入学习链接" class="headerlink" title="深入学习链接"></a>深入学习链接</h4><p><a href="https://laravelacademy.org/post/21991">https://laravelacademy.org/post/21991</a> 用户认证小了解关于自定义模型 在其中搜AuthServiceProvider<br><a href="https://laravelacademy.org/post/22035">https://laravelacademy.org/post/22035</a> oauth + passport详解讲的很好，在其中搜AuthServiceProvider</p>]]></content>
    
    
    <categories>
      
      <category>laravel，php，oauth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid x APlayer</title>
    <link href="/2021/10/01/Fluid-x-APlayer/"/>
    <url>/2021/10/01/Fluid-x-APlayer/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇分享如何在Fluid主题下添加音乐插件。Fluid x APlayer。</p><span id="more"></span><h4 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h4><p>APlayer中文文档 <a href="https://aplayer.js.org/#/zh-Hans/">https://aplayer.js.org/#/zh-Hans/</a></p><p>hexo-tag-aplayer文档 <a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md</a></p><h4 id="推荐步骤"><a href="#推荐步骤" class="headerlink" title="推荐步骤"></a>推荐步骤</h4><ol><li><p>在hexo博客的文件夹根目录打开git bash，输入如下命令安装插件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">npm install --save hexo-tag-aplayer<br><br>//安装完，将~node_modules\aplayer\dist文件copy至主题的source目录下<br></code></pre></td></tr></table></figure></li><li><p>在Fluid主题目录中，source目录下新建js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ap = <span class="hljs-keyword">new</span> APlayer(&#123;<br>    <span class="hljs-attr">container</span>: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;aplayer&#x27;</span>),<br><span class="hljs-attr">volume</span>: <span class="hljs-number">0.5</span>,<br>    <span class="hljs-attr">fixed</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">autoplay</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//自动播放</span><br>    <span class="hljs-attr">audio</span>: [<br>&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Talking to the Moon&#x27;</span>,<br>        <span class="hljs-attr">artist</span>: <span class="hljs-string">&#x27;Bruno Mars&#x27;</span>,<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">cover</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;, <br>]<br>&#125;);<br><span class="hljs-comment">//具体参数学习请看APlayer官方文档（已在学习链接中）</span><br><span class="hljs-comment">//简述一下关键：url填音乐的真实外部链接。cover就是封面图片真实链接。</span><br></code></pre></td></tr></table></figure></li><li><p>得到指定音乐的url与cover参数。（只以网易云音乐为例</p><p>打开网易云音乐网页版，随便找到一首歌，播放。他的url形如： <a href="https://music.163.com/#/song?id=28952146">https://music.163.com/#/song?id=28952146</a> 。然后将前者的id值套用到后者链接中xxxxxx位置 <a href="http://music.163.com/song/media/outer/url?id=xxxxxxx.mp3">http://music.163.com/song/media/outer/url?id=xxxxxxx.mp3</a> 。通过后者访问到的，重新生成的url就是其真实链接，也就是我们要填的url。对于获取cover，直接在网页版的cover图片上右击检查，鼠标放在cover上即可获得。</p></li><li><p>主题配置</p><p>在fluid主题配置文件_config.yml文件中搜索：custom_html.在其单引号中加入如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;/dist/APlayer.min.css&quot;</span>&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aplayer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/dist/APlayer.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/你命名的.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>hexo clean — hexo g — hexo d</p></li></ol><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>fluid主题不支持pjax。自行DIY会出现诸多问题。音乐无法在跳转页面后继续播放。建议选择适合的音乐。</p>]]></content>
    
    
    <categories>
      
      <category>blog美化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fluid</tag>
      
      <tag>aplayer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test_my_site</title>
    <link href="/2020/12/14/test-my-site/"/>
    <url>/2020/12/14/test-my-site/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇平淡无奇且无内容的测试罢了。</p><span id="more"></span><p>嘻嘻</p><p style="text-align:center;color:#8EC0E4;font-size:1.5em;font-weight: bold;">综合演示<br>优雅使用 Fluid 写文章 test效果</p>]]></content>
    
    
    <categories>
      
      <category>hexo测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>hexo init</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/12/hello-world/"/>
    <url>/2020/12/12/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub+Hexo deploy article wiz pic</title>
    <link href="/2020/12/11/hexo+github-picArticle/"/>
    <url>/2020/12/11/hexo+github-picArticle/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇将简述如何发布带图片的Markdown文件。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="修改全局-config-yml文件"><a href="#修改全局-config-yml文件" class="headerlink" title="修改全局_config.yml文件"></a>修改全局<code>_config.yml</code>文件</h3><p>在Blog根目录下，查看<code>_config.yml</code>文件，<code>command + f</code>搜索<code>post_asset_folder</code>字段，设置为true。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">post_asset_folder: <span class="hljs-literal">false</span>   ---&gt;  post_asset_folder: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> blog根目录<br>$ npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>ps：眼熟的同学就会发现，其做法应该与<code>Typora</code>显示图片的方式类似，采用同路径的文件夹形式。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>设置 <code>post_asset_folder</code> 参数后，在创建文章时，Hexo 会自动建立一个与文章同名的文件夹，可以把与该文章相关的所有资源都放到此文件夹内，这样就可以更方便的使用资源。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;test&quot;</span>  //创建名字为<span class="hljs-built_in">test</span>的文章<br>$ <span class="hljs-built_in">cd</span> ~/<span class="hljs-built_in">source</span>/_posts //进入文章目录<br>$ ls  //会出现如下文件，一个文章的md；一个文章同名的文件夹<br>test.md   <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>所要做的就是将对应的图片放入对应文件夹中即可。以下为图片用法。</p><p>实际上，也可以手动建立同名文件夹进行使用。只要安装了插件就可以。图片用法与Typora类似。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Git-merge/gitmerge1.png&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom:30%;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><img src="/2020/12/11/hexo+github-picArticle/picArticle.png" alt="测试图片" style="zoom:50%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git Merge</title>
    <link href="/2020/10/11/Git-merge/"/>
    <url>/2020/10/11/Git-merge/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇介绍Git操作之merge。</p><span id="more"></span><h3 id="Git-merge-合并-commits"><a href="#Git-merge-合并-commits" class="headerlink" title="Git merge:合并 commits"></a>Git merge:合并 commits</h3><p>merge 的意思是「合并」，它做的事也是合并: 指定一个 commit ，把它合并到当前的 commit 来。具体来讲， merge 做的事是:从目标 commit 和当前 commit (即 HEAD 所 指向的 commit )分叉的位置起，把目标commit 的路径上的所有 commit 的内容一并应用到当前 commit ，然后自动生成一个新的commit。</p><p>一般来说在master上操作： <code>git merge branch</code>  这样branch会合并到master上，实际操作是两者均延伸出一个新commit进行相交。</p><p><strong>merge的使用场景</strong></p><ol><li><p>就是合并分支</p></li><li><p>pull的内部操作：pull的实际操作其实是把远端仓库的内容用fetch取下来之后，用merge来合并。</p></li></ol><p><strong>特殊情况1：冲突</strong></p><p>首先两个分支改了同一个文件不同地方，merge会自动合并。但是该了相同地方就会产生冲突。他会提示你那里冲突。现在我们就需要做两件事情：1. 解决冲突;  2. 手动commit一下</p><p>对于前者来说：再打开冲突文件看一下。内容会改变。Git虽然无法处理冲突，但是他把两个分支冲突的内容放在一起，并用符号标记出他们的边界以及出处。</p><img src="/2020/10/11/Git-merge/gitmerge1.png" style="zoom:30%;"><p>我们如何操作呢？假设你要保留HEAD的修改，那么只要删除feature1的修改，再把辅助文字符号删除，保存退出就可以。<img src="/2020/10/11/Git-merge/gitmerge2.png" style="zoom:40%;">         (当然也可以选择更方便的merge工具来解决冲突。</p><p>对于后者来说：解决完冲突之后就要进行第二步，commit了。commit冲突文件。被冲突中断的merge在手动commit时候依旧会自动填写提交信息不用奇怪。我们先前的Git仓库都处于冲突待解决的中间状态，如果不解决冲突，也可以选择<code>merge --abort</code>来手动取消merge以达到merge前的状态。</p><p><strong>特殊情况2：HEAD领先于目标commit</strong></p><p>merge时，目标commit和HEAD处commit不存在分叉，而是单纯一条线上，且HEAD领先目标commit。此情况merge空操作。</p><p><strong>特殊情况3：HEAD落后于目标commit (fast-forward</strong> </p><p>Git会直接把HEAD以及他所指向的branch移动到目标commit。也就是前移罢了。看似此情况很少见，其实这种情况十分常见。因为这其实就是pull操作的一种经典：本地的master没有新提交，而远端仓库中有同事提交新内容到master。如果这时候在本地执行一次pull操作，就会由于HEAD落后于目标commit（也就是origin master）而造成fast-forward。而 <code>git pull</code> 的第二步操作 <code>merge</code> 的目标 <code>commit</code> ，是远端仓库的 <code>HEAD</code>，也就是 <code>origin/HEAD</code> ，所以 <code>git pull</code> 的第二步的完整内容是：<code>git merge origin/HEAD</code></p><p><strong>小总结：</strong></p><ol><li><code>merge</code> 的含义：从两个 <code>commit</code>「分叉」的位置起，把目标 <code>commit</code> 的内容应用到当前 <code>commit</code>（<code>HEAD</code> 所指向的 <code>commit</code>），并生成一个新的 <code>commit</code>；</li><li>merge的适用场景：<ol><li>单独开发的 <code>branch</code> 用完了以后，合并回原先的 <code>branch</code>；</li><li><code>git pull</code> 的内部自动操作。</li></ol></li><li>merge的三种特殊情况：<ol><li>冲突<ol><li>原因：当前分支和目标分支修改了同一部分内容，Git 无法确定应该怎样合并；</li><li>应对方法：解决冲突后手动 <code>commit</code>。</li></ol></li><li><code>HEAD</code> 领先于目标 <code>commit</code>：Git 什么也不做，空操作；</li><li><code>HEAD</code> 落后于目标 <code>commit</code>：fast-forward。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>merge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Handling errors</title>
    <link href="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/"/>
    <url>/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇介绍Git处理一些提交错误的大全。涉及revert，reset，rebase等。</p><span id="more"></span><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h3 id="修改非最新commit"><a href="#修改非最新commit" class="headerlink" title="修改非最新commit"></a>修改非最新commit</h3><h4 id="演示示例"><a href="#演示示例" class="headerlink" title="演示示例"></a>演示示例</h4><p>实际上有了交互式rebase，随便哪一个commit出错了都可以直接修改，只要在本地。</p><p><code>commit --amend</code> 可以修复最新 <code>commit</code> 的错误，但如果是倒数第二个 <code>commit</code> 写错了，怎么办？</p><p>在``git-exercise : sami`分支上进行操作。这条分支还是很干净的。提交三次作为实验。</p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224113247359.png" alt="1" style="zoom:67%;"><p>rebase回退两个。定位到1实际上。</p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224113824864.png" alt="2" style="zoom:67%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(sami) git rebase -i HEAD^^<br>Stopped at 229cf94...  rebase i 22<br>You can amend the commit now, with<br><br>  git commit --amend <br><br>Once you are satisfied with your changes, run<br><br>  git rebase --<span class="hljs-built_in">continue</span><br>➜  git-exercise git:(229cf94) <br></code></pre></td></tr></table></figure><p>可以看出停在了22这一次提交，就可以在22基础上就行改正。方式就是当作最新的一次commit就行修改即可。</p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224114324829.png" alt="3" style="zoom:50%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(229cf94) git add .<br>➜  git-exercise git:(229cf94) ✗ git commit --amend<br>[detached HEAD 8fec5f4] rebase i 22 修改了一下，并直接使用add .<br> 1 file changed, 2 insertions(+)<br>➜  git-exercise git:(8fec5f4) <br></code></pre></td></tr></table></figure><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224114622201.png" alt="4" style="zoom:67%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(8fec5f4) git rebase --<span class="hljs-built_in">continue</span><br>Auto-merging sami1.txt<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> sami1.txt<br>error: could not apply 45d3a51... rebase i 333<br>Resolve all conflicts manually, mark them as resolved with<br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> run <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: run <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort and get back to the state before <span class="hljs-string">&quot;git rebase&quot;</span>, run <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could not apply 45d3a51... rebase i 333<br><span class="hljs-comment"># 解决文件冲突</span><br>➜  git-exercise git:(8fec5f4) ✗ git add sami1.txt <br>➜  git-exercise git:(8fec5f4) ✗ git rebase --<span class="hljs-built_in">continue</span><br>[detached HEAD d480273] rebase i 333<br> 1 file changed, 2 insertions(+)<br>Successfully rebased and updated refs/heads/sami.<br><br></code></pre></td></tr></table></figure><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224115125866.png" alt="5" style="zoom:67%;"><h4 id="交互式rebase"><a href="#交互式rebase" class="headerlink" title="交互式rebase"></a>交互式rebase</h4><p>交互式 <code>rebase</code>，它可以在 <code>rebase</code> 开始之前指定一些额外操作。交互式 <code>rebase</code> 最常用的场景是修改写错的 <code>commit</code>，但也可以用作其他用途。它的大致用法：</p><ol><li>使用方式是 <code>git rebase -i 目标commit</code>；</li><li>在编辑界面中指定需要操作的 <code>commit</code>s 以及操作类型；</li><li>操作完成之后用 <code>git rebase --continue</code> 来继续 <code>rebase</code> 过程。</li></ol><p>如果不是最新的 <code>commit</code> 写错，就不能用 <code>commit --amend</code> 来修复了，而是要用 <code>rebase</code>。不过需要给 <code>rebase</code> 也加一个参数：<code>-i</code>。</p><p><code>rebase -i</code> 是 <code>rebase --interactive</code> 的缩写形式，意为「交互式 rebase」。</p><p>所谓「交互式 rebase」，就是在 <code>rebase</code> 的操作执行之前，你可以指定要 <code>rebase</code> 的 <code>commit</code> 链中的每一个 <code>commit</code> 是否需要进一步修改。那么你就可以利用这个特点，进行一次「原地 rebase」。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i HEAD^^ <span class="hljs-comment"># 定位到HEAD之前2个的commit上</span><br><span class="hljs-comment"># 把当前 commit （ HEAD 所指向的 commit） rebase 到 HEAD 之前 2 个的 commit 上</span><br><span class="hljs-comment">#把要修改的commit 前面的pick 改成edit 然后使用之前那一套</span><br>git add 处理要修改的文件<br>git commit --amend<br>git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><p>说明：在 Git 中，有两个「偏移符号」： <code>^</code> 和 <code>~</code>。</p><p><code>^</code> 的用法：在 <code>commit</code> 的后面加一个或多个 <code>^</code> 号，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>^</code> 的数量。例如：<code>master^</code> 表示 <code>master</code> 指向的 <code>commit</code> 之前的那个 <code>commit</code>； <code>HEAD^^</code> 表示 <code>HEAD</code> 所指向的 <code>commit</code> 往前数两个 <code>commit</code>。</p><p><code>~</code> 的用法：在 <code>commit</code> 的后面加上 <code>~</code> 号和一个数，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>~</code> 号后面的数。例如：<code>HEAD~5</code> 表示 <code>HEAD</code> 指向的 <code>commit</code>往前数 5 个 <code>commit</code>。</p><h3 id="丢弃最新提交"><a href="#丢弃最新提交" class="headerlink" title="丢弃最新提交"></a>丢弃最新提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br>➜  git-exercise git:(main) git reset --hard HEAD^<br>HEAD is now at 5ce1e26 rebase分支提交<br></code></pre></td></tr></table></figure><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224141451928.png" alt="6"></p><h3 id="丢弃非最新提交"><a href="#丢弃非最新提交" class="headerlink" title="丢弃非最新提交"></a>丢弃非最新提交</h3><p>不是最新的提交，就不能用 <code>reset --hard</code> 来撤销了。这种情况的撤销，就要用之前介绍过的一个指令：交互式 <code>rebase</code> ——<code>rebase -i</code>。</p><p>「撤销过往的提交」。方法有两种：</p><ol><li>用 <code>git rebase -i</code> 在编辑界面中删除想撤销的 <code>commit</code>s</li><li>用 <code>git rebase --onto</code> 在 rebase 命令中直接剔除想撤销的 <code>commit</code>s</li></ol><p>方法有两种，理念是一样的：在 <code>rebase</code> 的过程中去掉想撤销的 <code>commit</code>，让他它消失在历史中。</p><h4 id="演示示例丢弃rebase-1"><a href="#演示示例丢弃rebase-1" class="headerlink" title="演示示例丢弃rebase 1"></a>演示示例丢弃rebase 1</h4><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224144100865.png" alt="7" style="zoom:67%;"><p>把第一条删除</p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224144237652.png" alt="8" style="zoom:67%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(sami) git rebase -i sami~3<br>Auto-merging sami1.txt<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> sami1.txt<br>error: could not apply 8fec5f4... rebase i 22 修改了一下，并直接使用add .<br>Resolve all conflicts manually, mark them as resolved with<br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> run <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: run <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort and get back to the state before <span class="hljs-string">&quot;git rebase&quot;</span>, run <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could not apply 8fec5f4... rebase i 22 修改了一下，并直接使用add .<br>➜  git-exercise git:(4b3689d) ✗ git add .<br>➜  git-exercise git:(4b3689d) ✗ git rebase --<span class="hljs-built_in">continue</span><br>[detached HEAD f15d6cf] rebase i 22 修改了一下，并直接使用add .<br> 1 file changed, 3 insertions(+)<br>Successfully rebased and updated refs/heads/sami.<br></code></pre></td></tr></table></figure><p>从sami最新rebase到之前3个commits，HEAD到了4b3689，产生冲突。</p><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224144837828.png" alt="9"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">Sami de branch<br>xiugai<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>=======<br>Rebase交互式修改不是最新的commits 1<br>Rebase交互式修改不是最新的commits 22 修改倒数第二个22222<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8fec5f4 (rebase i 22 修改了一下，并直接使用add .)<br></code></pre></td></tr></table></figure><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224145457271.png" alt="10"></p><h4 id="演示合并无效提交"><a href="#演示合并无效提交" class="headerlink" title="演示合并无效提交"></a>演示合并无效提交</h4><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224164610330.png" alt="15"></p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224164721329.png" alt="16" style="zoom:67%;"><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224164909384.png" alt="17"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise-b git:(sami) git <span class="hljs-built_in">log</span>       <span class="hljs-comment"># 找到要rebase的位置</span><br>➜  git-exercise-b git:(sami) git rebase -i 4b36<br>[detached HEAD 66d9175] yaosuo一次就够<br> 1 file changed, 5 insertions(+)<br> create mode 100644 sami-yasuo.txt<br>Successfully rebased and updated refs/heads/sami.<br></code></pre></td></tr></table></figure><h3 id="错误commit已经push"><a href="#错误commit已经push" class="headerlink" title="错误commit已经push"></a>错误commit已经push</h3><p>讲当错误的 <code>commit</code> 已经被 <code>push</code> 上去时的解决方案。具体的方案有两类：</p><ol><li>如果出错内容在私有 <code>branch</code>：在本地把内容修正后，强制 <code>push</code> (<code>push -f</code>）一次就可以解决；</li><li>如果出错内容在 <code>master</code>：不要强制 <code>push</code>，而要用 <code>revert</code> 把写错的 <code>commit</code> 撤销。</li></ol><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224153204349.png" alt="11"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(main) git revert HEAD~1<br>CONFLICT (modify/delete): revert.txt deleted <span class="hljs-keyword">in</span> parent of 534e060 (test-revert) and modified <span class="hljs-keyword">in</span> HEAD. Version HEAD of revert.txt left <span class="hljs-keyword">in</span> tree.<br>error: could not revert 534e060... test-revert<br>hint: after resolving the conflicts, mark the corrected paths<br>hint: with <span class="hljs-string">&#x27;git add &lt;paths&gt;&#x27;</span> or <span class="hljs-string">&#x27;git rm &lt;paths&gt;&#x27;</span><br>hint: and commit the result with <span class="hljs-string">&#x27;git commit&#x27;</span><br>➜  git-exercise git:(main) ✗ git revert HEAD<br>error: Reverting is not possible because you have unmerged files.<br>hint: Fix them up <span class="hljs-keyword">in</span> the work tree, and <span class="hljs-keyword">then</span> use <span class="hljs-string">&#x27;git add/rm &lt;file&gt;&#x27;</span><br>hint: as appropriate to mark resolution and make a commit.<br>fatal: revert failed<br>➜  git-exercise git:(main) ✗ git status<br>On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 6 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>You are currently reverting commit 534e060.<br>  (fix conflicts and run <span class="hljs-string">&quot;git revert --continue&quot;</span>)<br>  (use <span class="hljs-string">&quot;git revert --skip&quot;</span> to skip this patch)<br>  (use <span class="hljs-string">&quot;git revert --abort&quot;</span> to cancel the revert operation)<br><br>Unmerged paths:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>  (use <span class="hljs-string">&quot;git add/rm &lt;file&gt;...&quot;</span> as appropriate to mark resolution)<br>deleted by them: revert.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br>➜  git-exercise git:(main) ✗ git add .<br>➜  git-exercise git:(main) git status<br>On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 6 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>You are currently reverting commit 534e060.<br>  (all conflicts fixed: run <span class="hljs-string">&quot;git revert --continue&quot;</span>)<br>  (use <span class="hljs-string">&quot;git revert --skip&quot;</span> to skip this patch)<br>  (use <span class="hljs-string">&quot;git revert --abort&quot;</span> to cancel the revert operation)<br><br>nothing to commit, working tree clean<br>➜  git-exercise git:(main) git revert --<span class="hljs-built_in">continue</span><br>On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 6 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>You are currently reverting commit 534e060.<br>  (all conflicts fixed: run <span class="hljs-string">&quot;git revert --continue&quot;</span>)<br>  (use <span class="hljs-string">&quot;git revert --skip&quot;</span> to skip this patch)<br>  (use <span class="hljs-string">&quot;git revert --abort&quot;</span> to cancel the revert operation)<br><br>nothing to commit, working tree clean<br>➜  git-exercise git:(main) git revert --abort<br>➜  git-exercise git:(main) git revert HEAD<br>[main 6db3b2e] Revert <span class="hljs-string">&quot;test-revert-1&quot;</span><br> 1 file changed, 1 deletion(-)<br></code></pre></td></tr></table></figure><h3 id="reset-的本质——不止可以撤销提交"><a href="#reset-的本质——不止可以撤销提交" class="headerlink" title="reset 的本质——不止可以撤销提交"></a>reset 的本质——不止可以撤销提交</h3><p><code>reset</code> 指令的本质：重置 <code>HEAD</code> 以及它所指向的 <code>branch</code> 的位置。同时，介绍了 <code>reset</code> 的三种参数：</p><ol><li><code>--hard</code>：重置位置的同时，清空工作目录的所有改动；</li><li><code>--soft</code>：重置位置的同时，保留工作目录和暂存区的内容，并把重置 <code>HEAD</code> 的位置所导致的新的文件差异放进暂存区。</li><li><code>--mixed</code>（默认）：重置位置的同时，保留工作目录的内容，并清空暂存区。</li></ol><p><code>reset --hard</code> 不仅可以撤销提交，还可以用来把 <code>HEAD</code> 和 <code>branch</code> 移动到其他的任何地方。</p><p><code>reset</code> 指令可以重置 <code>HEAD</code> 和 <code>branch</code> 的位置，不过在重置它们的同时，对工作目录可以选择不同的操作，而对工作目录的操作的不同，就是通过 <code>reset</code> 后面跟的参数来确定的。</p><h4 id="reset–hard"><a href="#reset–hard" class="headerlink" title="reset–hard"></a>reset–hard</h4><p><code>reset --hard</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 的同时，重置工作目录里的内容。当你在 <code>reset</code> 后面加了 <code>--hard</code> 参数时，你的工作目录里的内容会被完全重置为和 <code>HEAD</code> 的新位置相同的内容。换句话说，就是你的未提交的修改会被全部擦掉。</p><p>你的 <code>HEAD</code> 和当前 <code>branch</code> 切到上一条 <code>commit</code> 的同时，你工作目录里的新改动也一起全都消失了，不管它们是否被放进暂存区</p><h4 id="reset–soft"><a href="#reset–soft" class="headerlink" title="reset–soft"></a>reset–soft</h4><p><code>reset --soft</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 时，保留工作目录和暂存区中的内容，并把重置 <code>HEAD</code> 所带来的新的差异放进暂存区。<code>--hard</code> 会清空工作目录的改动，而 <code>--soft</code> 则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。还没有放入暂存区的文件仍然存在，实际上所有的工作目录文件都在。</p><h4 id="reset不加参数"><a href="#reset不加参数" class="headerlink" title="reset不加参数"></a>reset不加参数</h4><p><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code> 参数。它的行为是：保留工作目录，并且清空暂存区。由 <code>reset</code> 所导致的新提交的文件，直接变成未追踪文件。原来工作区的暂存没有暂存的都变成未暂存。</p><h3 id="Git-stash"><a href="#Git-stash" class="headerlink" title="Git stash"></a>Git stash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(main) git add gitstash.txt <br>➜  git-exercise git:(main) ✗ git status<br>On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 7 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>new file:   gitstash.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>gitstas1.txt<br><br>➜  git-exercise git:(main) ✗ git stash<br>Saved working directory and index state WIP on main: 6db3b2e Revert <span class="hljs-string">&quot;test-revert-1&quot;</span><br>➜  git-exercise git:(main) ✗ git checkout sami<br>Switched to branch <span class="hljs-string">&#x27;sami&#x27;</span><br>➜  git-exercise git:(sami) ✗ git status<br>On branch sami<br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>gitstas1.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br>➜  git-exercise git:(sami) ✗ git checkout main<br>Switched to branch <span class="hljs-string">&#x27;main&#x27;</span><br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 7 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br>➜  git-exercise git:(main) ✗ git status<br>On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 7 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>gitstas1.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br>➜  git-exercise git:(main) ✗ git stash pop<br>On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 7 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>new file:   gitstash.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>gitstas1.txt<br><br>Dropped refs/stash@&#123;0&#125; (1b5ba513b08ccf60326d068ae516cb35dc87c254)<br><br></code></pre></td></tr></table></figure><p>目前尚未暂存的也不会丢失。但为了保险起见：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash -u <span class="hljs-comment">#include 没有被 track 的文件</span><br>git checkout other<br><span class="hljs-comment"># after operate</span><br>git checkout old<br>git stash pop<br><span class="hljs-comment">#查看list</span><br>git stash list<br>-------------------<br>git stash //把本地的改动暂存起来<br>git stash save <span class="hljs-string">&quot;message&quot;</span> 执行存储时，添加备注，方便查找。<br>git stash pop // 应用最近一次暂存的修改，并删除暂存的记录<br>git stash apply  // 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;<span class="hljs-variable">$num</span>&#125; 。<br>git stash list // 查看 stash 有哪些存储<br>git stash clear // 删除所有缓存的 stash<br><br></code></pre></td></tr></table></figure><h3 id="找回已经删除的branch"><a href="#找回已经删除的branch" class="headerlink" title="找回已经删除的branch"></a>找回已经删除的branch</h3><p><code>reflog</code> 是 “reference log” 的缩写，使用它可以查看 Git 仓库中的引用的移动记录。如果不指定引用，它会显示 <code>HEAD</code> 的移动记录。假如你误删了 <code>branch1</code> 这个 <code>branch</code>，那么你可以查看一下 <code>HEAD</code> 的移动历史：</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224163311475.png" alt="12"></p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224163336189.png" alt="14" style="zoom:67%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise-b git:(main) git fetch<br>➜  git-exercise-b git:(main) git fetch origin main<br>From github.com:cutegentle/git-exercise<br> * branch            main       -&gt; FETCH_HEAD<br>➜  git-exercise-b git:(main) git pull<br>Updating 942f1d3..877ca87<br>Fast-forward<br> branch-a-1.txt | 3 +++<br> 1 file changed, 3 insertions(+)<br> create mode 100644 branch-a-1.txt<br>➜  git-exercise-b git:(main) git status<br>On branch main<br>Your branch is up to date with <span class="hljs-string">&#x27;origin/main&#x27;</span>.<br><br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><h3 id="回滚总结"><a href="#回滚总结" class="headerlink" title="回滚总结"></a>回滚总结</h3><h4 id="主流：checkout"><a href="#主流：checkout" class="headerlink" title="主流：checkout"></a>主流：checkout</h4><p>在sami分支，chekout回退至sami分支第一次提交进行一些debug。</p><p><img src="/2020/10/07/git%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%A4%A7%E5%85%A8/image-20220224171645640.png" alt="16"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise-b git:(sami) git checkout 08c7<br><span class="hljs-comment"># 会提示你head进入游离状态，也就是仅仅指向commit。</span><br><span class="hljs-comment"># 不必理会，可以发现文件已经退回到当时状态，可以随便操作</span><br><span class="hljs-comment"># 操作完直接切回原来分支就可以</span><br>Note: switching to <span class="hljs-string">&#x27;08c7&#x27;</span>.<br><br>You are <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make <span class="hljs-keyword">in</span> this<br>state without impacting any branches by switching back to a branch.<br><br>If you want to create a new branch to retain commits you create, you may<br><span class="hljs-keyword">do</span> so (now or later) by using -c with the switch <span class="hljs-built_in">command</span>. Example:<br><br>  git switch -c &lt;new-branch-name&gt;<br><br>Or undo this operation with:<br><br>  git switch -<br><br>Turn off this advice by setting config variable advice.detachedHead to <span class="hljs-literal">false</span><br><br>HEAD is now at 08c7221 sami分支第一次提交<br>➜  git-exercise-b git:(08c7221) git add .<br>➜  git-exercise-b git:(08c7221) ✗ git commit -m <span class="hljs-string">&quot;回退08c7进行一些更改&quot;</span><br>[detached HEAD 0cd559b] 回退08c7进行一些更改<br> 1 file changed, 1 insertion(+)<br>➜  git-exercise-b git:(0cd559b) git <span class="hljs-built_in">log</span><br>➜  git-exercise-b git:(0cd559b) git checkout sami<br>Warning: you are leaving 1 commit behind, not connected to<br>any of your branches:<br><br>  0cd559b 回退08c7进行一些更改<br><br>If you want to keep it by creating a new branch, this may be a good time<br>to <span class="hljs-keyword">do</span> so with:<br><br> git branch &lt;new-branch-name&gt; 0cd559b<br><br>Switched to branch <span class="hljs-string">&#x27;sami&#x27;</span><br><span class="hljs-comment"># 不加下面这句就不会产生新分支，权当测试了，毫无影响。</span><br><span class="hljs-comment"># 如果觉得在上面修改的一些东西是有效的，那么就可以用如下命令，新起一条分支，到时候可以合并进去</span><br>➜  git-exercise-b git:(sami) git branch testcheckoutrollback 0cd559b<br></code></pre></td></tr></table></figure><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><ul><li><strong>「当你用 reset 回滚到了某个版本后，那么在下一次 git 提交时，之前该版本后面的版本会被作为垃圾删掉。」</strong></li><li><strong>「当我们回退到一个旧版本后，此时再用 git log 查看提交记录，会发现之前的新版本记录没有了。如果第二天，你又想恢复到新版本怎么办？找不到新版本的 commit_id 怎么办？」</strong></li></ul><p><strong>「我们可以用 <code>git reflog</code> 查看历史命令，这样就可以看到之前新版本的 commit_id ，然后 <code>git reset --hard commit_id</code> 就可以回到之前的新版本代码」</strong></p><ul><li>虽然可以用 git reflog 查看本地历史，然后回复到之前的新版本代码，但是在别的电脑上是无法获取你的历史命令的，所以这种方法不安全。万一你的电脑突然坏了，这时候就无法回到未来的版本。</li></ul><p>这种方式回退是比较粗暴的，可能会丢失信息。</p><h4 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h4><p><strong>「千万不要用 <code>git reset</code> 回退已经被推送到公共仓库上的 提交，它只适用于回退本地修改（从未提交到公共仓库中）。如果你需要修复一个公共提交，最好使用 git revert」</strong>。revert适合发现bug在一个commits中。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git rebase</title>
    <link href="/2020/10/06/git-rebase/"/>
    <url>/2020/10/06/git-rebase/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇介绍Git rebase等操作。</p><span id="more"></span><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><h4 id="1-git-commit-–amend"><a href="#1-git-commit-–amend" class="headerlink" title="1. git commit –amend"></a>1. git commit –amend</h4><img src="/2020/10/06/git-rebase/image-20220223195135831.png" alt="image-20220223195135831" style="zoom:70%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(main) ✗ git add .<br>➜  git-exercise git:(main) ✗ git commit -m <span class="hljs-string">&quot;开始rebase，先测commit撤销&quot;</span><br>[main b00c892] 开始rebase，先测commit撤销<br> 1 file changed, 2 insertions(+)<br> create mode 100644 rebase1.txt<br>➜  git-exercise git:(main) git <span class="hljs-built_in">log</span><br>➜  git-exercise git:(main) git <span class="hljs-built_in">log</span>             <br>➜  git-exercise git:(main) ✗ git add rebase1.txt <br>➜  git-exercise git:(main) ✗ git commit --amend<br>[main 833283c] 测试commit --amend 是否能用<br> 1 file changed, 2 insertions(+)<br> create mode 100644 rebase1.txt<br></code></pre></td></tr></table></figure><p>先提交一次在gitexercise上。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原来文件内容：<br>先测试<span class="hljs-keyword">commit</span>撤销开始<br>修改后：<br>先测试<span class="hljs-keyword">commit</span>撤销开始,我修改了一下错误以amend<br></code></pre></td></tr></table></figure><img src="/2020/10/06/git-rebase/image-20220223195653217.png" alt="image-20220223195653217" style="zoom:70%;"><p>显而易见：</p><p>用 <code>commit --amend</code> 可以修复当前提交的错误。使用方式：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure><p>需要注意的有一点：<code>commit --amend</code> 并不是直接修改原 <code>commit</code> 的内容，而是生成一条新的 <code>commit</code>。</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>前置条件。</p><img src="/2020/10/06/git-rebase/image-20220223201716036.png" alt="image-20220223201716036" style="zoom:80%;"><p>在test-rebase分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase main<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(test-rebase) git rebase main<br>Auto-merging rebase1.txt<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> rebase1.txt<br>error: could not apply afeeb31... rebase分支提交<br>Resolve all conflicts manually, mark them as resolved with<br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> run <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: run <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort and get back to the state before <span class="hljs-string">&quot;git rebase&quot;</span>, run <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could not apply afeeb31... rebase分支提交<br><span class="hljs-comment"># nice</span><br></code></pre></td></tr></table></figure><img src="/2020/10/06/git-rebase/image-20220223202146101.png" alt="image-20220223202146101" style="zoom:50%;"><p>打开文件可以看到冲突的地方已经标出来了。解决冲突之后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(cb9e2c9) ✗ git add rebase1.txt <br>➜  git-exercise git:(cb9e2c9) ✗ git rebase --<span class="hljs-built_in">continue</span><br>[detached HEAD 5ce1e26] rebase分支提交<br> 2 files changed, 2 insertions(+), 2 deletions(-)<br> create mode 100644 rebase2.txt<br>Successfully rebased and updated refs/heads/test-rebase.<br></code></pre></td></tr></table></figure><img src="/2020/10/06/git-rebase/image-20220223202637695.png" alt="image-20220223202637695" style="zoom:80%;"><p>test-rebase分支直接 以 main分支最新提交为起点 再把自己分支上的提交依次排在main起点开始。</p><p>通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 <code>rebase</code> 的含义。</p><p>另外，在 <code>rebase</code> 之后，记得切回 <code>master</code> 再 <code>merge</code> 一下，把 <code>master</code> 移到最新的 <code>commit</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge branch1<br><span class="hljs-comment"># 这里的merge实际上 是 fast-forward</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(test-rebase) git checkout main<br>Switched to branch <span class="hljs-string">&#x27;main&#x27;</span><br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 3 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br>➜  git-exercise git:(main) git merge test-rebase <br>Updating cb9e2c9..5ce1e26<br>Fast-forward<br> rebase1.txt | 3 +--<br> rebase2.txt | 1 +<br> 2 files changed, 2 insertions(+), 2 deletions(-)<br> create mode 100644 rebase2.txt<br></code></pre></td></tr></table></figure><p>其实很好记。对于一般情况，总会操作master。那么</p><ol><li>merge实际上都要从master出发使用，<code>git merge other-branch</code></li><li>rebase实际上都是：<code>git rebase master</code>意思就是以master为基点，变基。</li><li>注意的是操作master的rebase，最后要在master上merge一下以达到最新。</li></ol><img src="/2020/10/06/git-rebase/image-20220223203346518.png" alt="image-20220223203346518" style="zoom:80%;"><img src="/2020/10/06/git-rebase/image-20220223203422000.png" alt="image-20220223203422000" style="zoom:80%;"><p>如果是merge而不是rebase，从<code>开始测试rebase（包括</code>这个commit开始一共4个因为会新产生一个，并产生分叉。</p><p>对比rebase和merge。</p><p><img src="/2020/10/06/git-rebase/image-20220223203713858.png" alt="image-20220223203713858"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>rebase</code> 指令，它可以改变 <code>commit</code> 序列的基础点。它的使用方式很简单：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> rebase 目标基础点<br></code></pre></td></tr></table></figure><p>需要说明的是，<code>rebase</code> 是站在需要被 <code>rebase</code> 的 <code>commit</code> 上进行操作，这点和 <code>merge</code> 是不同的。</p><h3 id="下一篇：处理一些提交上的错误大全"><a href="#下一篇：处理一些提交上的错误大全" class="headerlink" title="下一篇：处理一些提交上的错误大全"></a>下一篇：处理一些提交上的错误大全</h3>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用指令大全</title>
    <link href="/2020/10/05/git%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/10/05/git%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇介绍Git 常用指令大全。</p><span id="more"></span><h2 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .                                将所有改动放进暂存区<br>git commit -m <span class="hljs-string">&quot;描述&quot;</span>                      提交并附带概要信息<br>git pull                                 一般都在main拉取所有的最新代码<br>git push                                 默认只能master分支，只有其建立联系<br>---------------------------------------------------------------------------------------<br>git <span class="hljs-built_in">log</span>                                  查看日志<br>git status                               查看工作区状态<br>git branch 名称                          创建分支<br>git checkout 名称                        切换分支<br>git checkout -b 名称                     创建并切换到新分支<br>git branch -d 名称                       删除该分支（不能删除当前所在的分支，不能删除没有合并到master上的分支）<br>git branch -D 名称                       删除该分支（可以删除没有合并到master上的分支）<br>git commit --amend                       对最新的一条commit进行修正<br>git reset --hard HEAD^                   丢弃最新提交（未提交的内容会被擦掉）head branch同时移动<br>git reset --soft HEAD^                   丢弃最新提交（未提交的内容不会被擦掉）<br>git revert HEAD^                         对于master上回退一个版本十分友好<br>git rebase 目标基础点                     重新设置基础点，一条线上操作为空操作<br>git merge 名称                           将分支合并到head指向的分支，对象与rebase相反<br>git push origin localbranch              将代码推送到远程仓库的指定分支<br>git push -d origin branchName            删除远程分支<br>git stash                                暂存代码<br>git stash pop                            弹出暂存代码<br>git remote -v                            查看远程<br>git remote show origin查看具体的一些远程关系<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feature Branching</title>
    <link href="/2020/10/05/FeatureBranching/"/>
    <url>/2020/10/05/FeatureBranching/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最流行的工作流。</p><span id="more"></span><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>这种工作流的核心内容可以总结为两点：</p><ol><li>任何新的功能（feature）或 bug 修复全都新建一个 <code>branch</code> 来写；</li><li><code>branch</code> 写完后，合并到 <code>master</code>，然后删掉这个 <code>branch</code>。</li></ol><p>Feature Branching 这种工作流，为团队开发时两个关键的问题——代码分享和一人多任务——提供了解决方案。</p><p>此处建议新起仓库模拟多人进行实际操作。以下不仅有checkout练习，还涉及pull，merge等操作。</p><h3 id="1-代码分享"><a href="#1-代码分享" class="headerlink" title="1. 代码分享"></a>1. 代码分享</h3><h4 id="colleague"><a href="#colleague" class="headerlink" title="colleague"></a>colleague</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">此前我的仓库，和新建同事a的仓库应该是一样的。还需要在同时新建同事b，他要在一切前要push origin master到6<br>git checkout -b books<br>-----after n commits<br>git push origin books<br></code></pre></td></tr></table></figure><img src="/2020/10/05/FeatureBranching/image-20220222200702534.png" alt="本地实际从master开始checkout写，所以直线" style="zoom:67%;"><img src="/2020/10/05/FeatureBranching/image-20220222200900550.png" alt="但此时经过其他同事origin/master已经到6" style="zoom:67%;"><h4 id="Me"><a href="#Me" class="headerlink" title="Me"></a>Me</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br>git chekcout books<br>---看了没问题<br>git checkout master<br>git pull <span class="hljs-comment"># merge 之前 pull 一下，让 master 更新到和远程仓库同步</span><br>git merge books<br>---合并后<br>git push<br>git branch -d books<br>git push origin -d books <span class="hljs-comment"># 用 -d 参数把远程仓库的 branch 也删了</span><br></code></pre></td></tr></table></figure><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>目前模拟：</p><h5 id="git-a"><a href="#git-a" class="headerlink" title="git-a"></a>git-a</h5><p>注意三个仓库的起点都是红框处。</p><p>a在原来的基础上，新建一条分支进行开发。并完成两次的本地提交。</p><img src="/2020/10/05/FeatureBranching/image-20220223103011597.png" alt="3" style="zoom:50%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise-a git:(main) git checkout -b test-a<br>Switched to a new branch <span class="hljs-string">&#x27;test-a&#x27;</span><br>➜  git-exercise-a git:(test-a) git add .<br>➜  git-exercise-a git:(test-a) ✗ git commit -m <span class="hljs-string">&quot;分支a 第一次提交&quot;</span><br>[test-a a0a68fe] 分支a 第一次提交<br> 1 file changed, 2 insertions(+)<br> create mode 100644 branch-a-1.txt<br>➜  git-exercise-a git:(test-a) git status<br>On branch test-a<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>modified:   branch-a-1.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br>➜  git-exercise-a git:(test-a) ✗ git add .<br>➜  git-exercise-a git:(test-a) ✗ git commit -m <span class="hljs-string">&quot;分支a 第 2 次提交&quot;</span><br>[test-a 17ff65f] 分支a 第 2 次提交<br> 1 file changed, 1 insertion(+)<br>➜  git-exercise-a git:(test-a) git <span class="hljs-built_in">log</span><br>➜  git-exercise-a git:(test-a) git push origin test-a <br>remote: Create a pull request <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;test-a&#x27;</span> on GitHub by visiting:<br>remote:      https://github.com/cutegentle/git-exercise/pull/new/test-a<br>remote: <br>To github.com:cutegentle/git-exercise.git<br> * [new branch]      test-a -&gt; test-a<br></code></pre></td></tr></table></figure><h5 id="git-exercise"><a href="#git-exercise" class="headerlink" title="git-exercise"></a>git-exercise</h5><p>最后git-exercise将模拟pull的本质。当前HEAD在起点处，尚未修改。</p><img src="/2020/10/05/FeatureBranching/image-20220223103215023.png" alt="4" style="zoom:50%;"><h5 id="git-b"><a href="#git-b" class="headerlink" title="git-b"></a>git-b</h5><p>b做的变化就是在main上提交一次并push到origin</p><img src="/2020/10/05/FeatureBranching/image-20220223103522214.png" alt="5" style="zoom:50%;"><p>一切准备就绪。我就是下图。还在之前的版本。main落后一个，没有testa分支。</p><img src="/2020/10/05/FeatureBranching/image-20220223104715054.png" alt="6" style="zoom:50%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(main) git pull<br>Updating 68a8e97..942f1d3<br>Fast-forward<br> b-main-ahead1.txt | 2 ++<br> 1 file changed, 2 insertions(+)<br> create mode 100644 b-main-ahead1.txt<br>git <span class="hljs-built_in">log</span> 会显示到最新的main，所有main上引用都到最新版本。<br></code></pre></td></tr></table></figure><img src="/2020/10/05/FeatureBranching/image-20220223105401530.png" alt="7" style="zoom:50%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">此时可以明确看到，test-a在本地仍没有，那么真的没有吗？<br>➜  git-exercise git:(main) git checkout test-a <br>Branch <span class="hljs-string">&#x27;test-a&#x27;</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">&#x27;test-a&#x27;</span> from <span class="hljs-string">&#x27;origin&#x27;</span>.<br>Switched to a new branch <span class="hljs-string">&#x27;test-a&#x27;</span><br>直接切换分支即可，Git会自动建立分支来追踪远程的分支。<br>在当前分支查看git <span class="hljs-built_in">log</span><br>commit 17ff65f25dba46a086f53b2516fdf6e563b848c0 (HEAD -&gt; test-a, origin/test-a)<br>在此再次提醒：branch本质是一串 commits<br></code></pre></td></tr></table></figure><img src="/2020/10/05/FeatureBranching/image-20220223110639551.png" alt="8" style="zoom:50%;"><p>至此，对于原来白板的git-exercise仓库。main分支更新到最新，同时也获取到远程的其他分支。</p><p>我在test-a分支上阅读了同事的代码。</p><img src="/2020/10/05/FeatureBranching/image-20220223111051660.png" alt="9" style="zoom:50%;"><p>觉得还是不错的。就合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(test-a) git checkout main<br>Switched to branch <span class="hljs-string">&#x27;main&#x27;</span><br>Your branch is up to date with <span class="hljs-string">&#x27;origin/main&#x27;</span>.会先提示你要不要在merge前pull<br>➜  git-exercise git:(main) git merge test-a <br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> branch-a-1.txt | 3 +++<br> 1 file changed, 3 insertions(+)<br> create mode 100644 branch-a-1.txt<br></code></pre></td></tr></table></figure><img src="/2020/10/05/FeatureBranching/image-20220223111558098.png" alt="10" style="zoom:50%;"><p><img src="/2020/10/05/FeatureBranching/image-20220223112103342.png" alt="11"></p><img src="/2020/10/05/FeatureBranching/image-20220223112251957.png" alt="12" style="zoom:50%;"><p>在main上git log查看发现，多出三个commits，因此会提示main分支上超前三个版本。merge会产生一次新的额外commit这里先说明，之后细说。</p><p><img src="/2020/10/05/FeatureBranching/image-20220223113315213.png" alt="13"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull 目前我只运用在main上，因为最方便直接。会拉取所有remote的最新代码，本地没有的分支会自动创建。<br>git push 就看上图，理解为默认只推送当前分支。一般在本地main上merge后直接push即可。<br>之后有空研究下在其他分支进行操作会怎么样。在其他分支上是不能简写成git push的<br></code></pre></td></tr></table></figure><img src="/2020/10/05/FeatureBranching/image-20220223113801958.png" alt="14" style="zoom:50%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  git-exercise git:(main) git branch -d test-a <br>Deleted branch test-a (was 17ff65f).<br>➜  git-exercise git:(main) git push origin -d test-a        <br>To github.com:cutegentle/git-exercise.git<br> - [deleted]         test-a<br></code></pre></td></tr></table></figure><img src="/2020/10/05/FeatureBranching/image-20220223114301105.png" alt="15" style="zoom:50%;"><p>删除本地分支，删除远程分支。实际删除的只是引用，提交还是在的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">同事：<br>git checkout -b books<br>---after n commits<br>git push origin books<br><br><span class="hljs-comment"># 我：</span><br>git pull<br>git chekcout books<br>---看了没问题<br>git checkout master<br>git pull <span class="hljs-comment"># merge 之前 pull 一下，让 master 更新到和远程仓库同步</span><br>git merge books<br>---合并后<br>git push<br>git branch -d books<br>git push origin -d books <span class="hljs-comment"># 用 -d 参数把远程仓库的 branch 也删了</span><br><br>pull request后续介绍。<br></code></pre></td></tr></table></figure><h3 id="2-what-is-git-pull"><a href="#2-what-is-git-pull" class="headerlink" title="2. what is git pull"></a>2. what is git pull</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">NAME<br>       git-pull - Fetch from and integrate with another repository or a local branch<br><br>SYNOPSIS<br>       git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]<br><br><br>DESCRIPTION<br>       Incorporates changes from a remote repository into the current branch. In its default mode, git pull is<br>       shorthand for git fetch followed by git merge FETCH_HEAD.<br><br>       More precisely, git pull runs git fetch with the given parameters and calls git merge to merge the retrieved<br>       branch heads into the current branch. With --rebase, it runs git rebase instead of git merge.<br><br>       &lt;repository&gt; should be the name of a remote repository as passed to git-fetch(1). &lt;refspec&gt; can name an<br>       arbitrary remote ref (for example, the name of a tag) or even a collection of refs with corresponding<br>       remote-tracking branches (e.g., refs/heads/*:refs/remotes/origin/*), but usually it is the name of a branch in<br>       the remote repository.<br><br>       Default values for &lt;repository&gt; and &lt;branch&gt; are read from the &quot;remote&quot; and &quot;merge&quot; configuration for the<br>       current branch as set by git-branch(1) --track.<br><br>       Assume the following history exists and the current branch is &quot;master&quot;:<br><br>                     A---B---C master on origin<br>                    /<br>               D---E---F---G master<br>                   ^<br>                   origin/master in your repository<br><br><br>       Then &quot;git pull&quot; will fetch and replay the changes from the remote master branch since it diverged from the local<br>       master (i.e., E) until its current commit (C) on top of master and record the result in a new commit along with<br>       the names of the two parent commits and a log message from the user describing the changes.<br><br>:<br><br></code></pre></td></tr></table></figure><h3 id="3-see-commit"><a href="#3-see-commit" class="headerlink" title="3. see commit"></a>3. see commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br>git <span class="hljs-built_in">log</span> -p<br>git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br>git show<br>git show 953f <span class="hljs-comment">#至少4位</span><br>git diff --staged<br></code></pre></td></tr></table></figure><p>这一节介绍了一些查看改动内容的方法，大致有这么几类：</p><ol><li>查看历史中的多个commit：<code>log</code><ol><li>查看详细改动： <code>git log -p</code></li><li>查看大致改动：<code>git log --stat</code></li></ol></li><li>查看具体某个commit ：<code>show</code><ol><li>要看最新 <code>commit</code> ，直接输入 <code>git show</code> ；要看指定 <code>commit</code> ，输入 <code>git show commit的引用或SHA-1</code></li><li>如果还要指定文件，在 <code>git show</code> 的最后加上文件名</li></ol></li><li>查看未提交的内容：<code>diff</code><ol><li>查看暂存区和上一条 <code>commit</code> 的区别：<code>git diff --staged</code>（或 <code>--cached</code>）</li><li>查看工作目录和暂存区的区别：<code>git diff</code> 不加选项参数</li><li>查看工作目录和上一条 <code>commit</code> 的区别：<code>git diff HEAD</code></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git push &amp; checkout</title>
    <link href="/2020/10/04/git-push/"/>
    <url>/2020/10/04/git-push/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇介绍Git push &amp; checkout的本质。曾经的我认为：<code>push</code> 指令做的事是「上传本地提交」。</p><span id="more"></span><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h3 id="先说关键点"><a href="#先说关键点" class="headerlink" title="先说关键点"></a>先说关键点</h3><p><code>push</code> 这个指令的本质：</p><ol><li><code>push</code> 是把当前的分支上传到远程仓库，并把这个 <code>branch</code> 的路径上的所有 <code>commit</code>s 也一并上传。</li><li><code>push</code> 的时候，如果当前分支是一个本地创建的分支，需要指定远程仓库名和分支名，用 <code>git push origin branch_name</code> 的格式，而不能只用 <code>git push</code>（只能把本地 <code>master</code> 的最新位置更新到远端，并且把它的路径上的  <code>commit</code>s 上传）；</li><li><code>push</code> 的时候之后上传当前分支，并不会上传 <code>HEAD</code>；远程仓库的 <code>HEAD</code> 是永远指向默认分支（即 <code>master</code>）的。<code>push</code> 的时候只会上传当前的 <code>branch</code> 的指向，并不会把本地的 <code>HEAD</code> 的指向也一起上传到远程仓库。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) git push<br>只能在main上简写。<br>$ git-exercise git:(sami) git push origin sami<br>~<br>remote: Create a pull request <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;sami&#x27;</span> on GitHub by visiting:<br>remote:      https://github.com/cutegentle/git-exercise/pull/new/sami<br>To github.com:cutegentle/git-exercise.git<br> * [new branch]      sami -&gt; sami<br></code></pre></td></tr></table></figure><p><img src="/2020/10/04/git-push/image-20220222180224235.png" alt="1"></p><p>在sami分支使用<code>tig</code>查看提交历史，更能理解branch可以作为从initial开始的一条<strong>串</strong>。</p><h3 id="checkout-本质"><a href="#checkout-本质" class="headerlink" title="checkout 本质"></a>checkout 本质</h3><p>实质上，<code>checkout</code> 并不止可以切换 <code>branch</code>。<code>checkout</code> 本质上的功能其实是：签出（ checkout ）指定的 <code>commit</code>。</p><p><code>git checkout branch名</code> 的本质，其实是把 <code>HEAD</code> 指向指定的 <code>branch</code>，然后签出这个 <code>branch</code> 所对应的 <code>commit</code> 的工作目录。所以同样的，<code>checkout</code> 的目标也可以不是 <code>branch</code>，而直接指定某个 <code>commit</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout HEAD^^<br>git checkout master~5<br>git checkout 78a4bc<br>git checkout 78a4bc^<br></code></pre></td></tr></table></figure><p><strong>存在疑问：</strong></p><p><img src="/2020/10/04/git-push/image-20220222182535129.png" alt="2"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) git checkout 128b<br>Note: switching to <span class="hljs-string">&#x27;128b&#x27;</span>.<br><br>You are <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make <span class="hljs-keyword">in</span> this<br>state without impacting any branches by switching back to a branch.<br><br>If you want to create a new branch to retain commits you create, you may<br><span class="hljs-keyword">do</span> so (now or later) by using -c with the switch <span class="hljs-built_in">command</span>. Example:<br><br>  git switch -c &lt;new-branch-name&gt;<br><br>Or undo this operation with:<br><br>  git switch -<br><br>Turn off this advice by setting config variable advice.detachedHead to <span class="hljs-literal">false</span><br><br>HEAD is now at 128b182 Initial commit<br>恢复：<br>$ git-exercise git:(128b182) git checkout main<br>Previous HEAD position was 128b182 Initial commit<br>Switched to branch <span class="hljs-string">&#x27;main&#x27;</span><br>Your branch is up to date with <span class="hljs-string">&#x27;origin/main&#x27;</span>.<br></code></pre></td></tr></table></figure><h4 id="checkout-和-reset-的不同"><a href="#checkout-和-reset-的不同" class="headerlink" title="checkout 和 reset 的不同"></a>checkout 和 reset 的不同</h4><p><code>checkout</code> 和 <code>reset</code> 都可以切换 <code>HEAD</code> 的位置，它们除了有许多细节的差异外，最大的区别在于：<code>reset</code> 在移动 <code>HEAD</code> 时会带着它所指向的 <code>branch</code> 一起移动，而 <code>checkout</code> 不会。当你用 <code>checkout</code> 指向其他地方的时候，<code>HEAD</code> 和 它所指向的 <code>branch</code> 就自动脱离了。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Branch</title>
    <link href="/2020/10/03/git-branch/"/>
    <url>/2020/10/03/git-branch/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇介绍Git分支的一些操作，以及原理。</p><span id="more"></span><h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>当本地无分支时。一键创建分支并切换。<strong>切换分支后，HEAD改变。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) git checkout -b sami<br>Switched to a new branch <span class="hljs-string">&#x27;sami&#x27;</span><br><br>$ git branch sami                          创建分支<br>$ git checkout sami                        切换分支<br></code></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ol><li>在main分支提交两次。文件分别<code>master1.txt</code>, <code>master2.txt</code>。</li><li>在选中处，创建并切换分支sami。</li><li>之后在sami分支提交两次，文件为同一文件<code>sami1.txt</code>。</li></ol><img src="/2020/10/03/git-branch/image-20220222164239028.png" alt="1" style="zoom:67%;"><p>理解上图。之所以一条线是因为自从checkout至sami，main无修改，sami基于main。在sami分支目前三个文件。而切换至main分支仍然是之前两个文件。通俗来讲，再切换至main做一次commit就会出现分叉了。</p><p><img src="/2020/10/03/git-branch/image-20220222171445719.png" alt="2"></p><p>sourcetree中空心即为本地HEAD指向。上图切换至sami分支显然main修改的最新文件它不会有。</p><p><code>checkout</code> 的意思就是把某个 <code>commit</code> 作为当前 <code>commit</code>，把 <code>HEAD</code> 移动过去，并把工作目录的文件内容替换成这个 <code>commit</code> 所对应的内容。</p><p><strong>上图实际包含很多知识点。下面先介绍。</strong></p><p>Git 提供了「引用」的机制：使用固定的字符串作为引用，指向某个 <code>commit</code>，作为操作 <code>commit</code> 时的快捷方式。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p> <code>HEAD</code> 是引用中最特殊的一个：它是<strong>指向当前 <code>commit</code> 的引用</strong>。所谓**当前 <code>commit</code>**这个概念很简单，它指的就是当前工作目录所对应的 <code>commit</code>。</p><p>要想理解这一句。首先建立概念，对于Git来说，核心是commit <strong>s</strong>，工作目录的代码归根结底根据commit而变。</p><p>每次当有新的 <code>commit</code> 的时候，工作目录自动与最新的 <code>commit</code> 对应；而与此同时，<code>HEAD</code> 也会转而指向最新的 <code>commit</code>。事实上，当使用 <code>checkout</code>、<code>reset</code> 等指令手动指定改变当前 <code>commit</code> 的时候，<code>HEAD</code> 也会一起跟过去。</p><p>总之，当前 <code>commit</code> 在哪里，<code>HEAD</code> 就在哪里，这是一个永远自动指向当前 <code>commit</code> 的引用，所以你永远可以用 <code>HEAD</code> 来操作当前 <code>commit</code>。</p><p>此时可以理解为什么切换分支后，文件会不同。归根结底：切换到main分支时，HEAD指向main最新commit。而切换到sami分支时，查看log，HEAD指向sami分支最新commit。</p><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p><code>HEAD</code> 是 Git 中一个独特的引用，它是唯一的。而除了 <code>HEAD</code> 之外，Git 还有一种引用，叫做 <code>branch</code>（分支）。<code>HEAD</code> 除了可以指向 <code>commit</code>，还可以指向一个 <code>branch</code>，当它指向某个 <code>branch</code> 的时候，会通过这个 <code>branch</code> 来间接地指向某个 <code>commit</code>；另外，当 <code>HEAD</code> 在提交时自动向前移动的时候，它会像一个拖钩一样带着它所指向的 <code>branch</code> 一起移动。每当创建一个 <code>commit</code>，那么 <code>HEAD</code> 会带着 <code>master</code> 一起移动到最新的 <code>commit</code>。</p><h3 id="delete-branch"><a href="#delete-branch" class="headerlink" title="delete branch"></a>delete branch</h3><p>不常用。</p><p>删除 <code>branch</code> 的方法非常简单：<code>git branch -d 名称</code>。例如要删除 <code>feature1</code> 这个 branch：</p><p>注意：1. <code>HEAD</code> 指向的 <code>branch</code> 不能删除。如果要删除 <code>HEAD</code> 指向的 <code>branch</code>，需要先用 <code>checkout</code> 把 <code>HEAD</code> 指向其他地方。2. 由于 Git 中的 <code>branch</code> 只是一个引用，所以删除 <code>branch</code> 的操作也只会删掉这个引用，并不会删除任何的 <code>commit</code>。（不过如果一个 <code>commit</code> 不在任何一个 <code>branch</code> 的「路径」上，那么在一定时间后，它会被 Git 的回收机制删除掉。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d feature1<br>//出于安全考虑，没有被合并到 master 过的 branch 在删除时会失败,强制删除用如下：<br>$ git branch -D feature1<br></code></pre></td></tr></table></figure><h3 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h3><p>所谓「引用」（reference），其实就是一个个的字符串。这个字符串可以是一个 <code>commit</code> 的 SHA-1 码（例：<code>c08de9a4d8771144cd23986f9f76c4ed729e69b0</code>），也可以是一个 <code>branch</code>（例：<code>ref: refs/heads/feature3</code>）。</p><p>Git 中的 <code>HEAD</code> 和每一个 <code>branch</code> 以及其他的引用，都是以文本文件的形式存储在本地仓库 <code>.git</code> 目录中，而 Git 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>HEAD</code> 是指向当前 <code>commit</code> 的引用，它具有唯一性，每个仓库中只有一个 <code>HEAD</code>。在每次提交时它都会自动向前移动到最新的 <code>commit</code> 。</li><li><code>branch</code> 是一类引用。<code>HEAD</code> 除了直接指向 <code>commit</code>，也可以通过指向某个 <code>branch</code> 来间接指向 <code>commit</code>。当 <code>HEAD</code> 指向一个 <code>branch</code> 时，<code>commit</code> 发生时，<code>HEAD</code> 会带着它所指向的 <code>branch</code> 一起移动。</li><li>master是 Git 中的默认branch，它和其它branch的区别在于：<ol><li>新建的仓库中的第一个 <code>commit</code> 会被 <code>master</code> 自动指向；</li><li>在 <code>git clone</code> 时，会自动 <code>checkout</code> 出 <code>master</code>。</li></ol></li><li>branch的创建、切换和删除：<ol><li>创建 <code>branch</code> 的方式是 <code>git branch 名称</code> 或 <code>git checkout -b 名称</code>（创建后自动切换）；</li><li>切换的方式是 <code>git checkout 名称</code>；</li><li>删除的方式是 <code>git branch -d 名称</code>。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Start</title>
    <link href="/2020/10/02/git-quick-start/"/>
    <url>/2020/10/02/git-quick-start/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇介绍Git基础操作。</p><span id="more"></span><h2 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:cutegentle/git-exercise.git<br>$ git-exercise git:(main) la<br>total 40<br>drwxr-xr-x  12 w  staff   384B  9 21 17:43 .git<br>-rw-r--r--   1 w  staff   1.4K  9 21 17:43 .gitignore<br>-rw-r--r--   1 w  staff    11K  9 21 17:43 LICENSE<br>-rw-r--r--   1 w  staff    28B  9 21 17:43 README.md<br>$ <br>$ git-exercise git:(main) ls<br></code></pre></td></tr></table></figure><p>讲下工作区等概念，以及目录文件的一些用处。可结合sourcetree界面。</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) git <span class="hljs-built_in">log</span><br>commit 128b182c3a76421ee5c321ad230579c53e9ec488 (HEAD -&gt; main, origin/main, origin/HEAD)<br>$ q //quit<br></code></pre></td></tr></table></figure><p>引用，commit等相关知识。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) git status<br>On branch main<br>Your branch is up to date with <span class="hljs-string">&#x27;origin/main&#x27;</span>.<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>master1.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br><br></code></pre></td></tr></table></figure><h3 id="git-add-amp-commit"><a href="#git-add-amp-commit" class="headerlink" title="git add &amp; commit"></a>git add &amp; commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) ✗ git add .<br>$ git-exercise git:(main) ✗ git commit -m <span class="hljs-string">&quot;main第一次本地提交&quot;</span><br>$ git-exercise git:(main) git status<br>On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 1 commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) git push origin<br>$ git-exercise git:(main) git push origin main<br></code></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git-exercise git:(main) git pull origin main <br></code></pre></td></tr></table></figure><p>值得一提的是要注意HEAD，branch的指向。</p><p><strong>以上为git最为基本的命令。需烂熟于心。</strong></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>What is Git ？</title>
    <link href="/2020/10/01/whatIsGit/"/>
    <url>/2020/10/01/whatIsGit/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>你真的知道什么是Git吗？</strong></p><span id="more"></span><p style="text-align:center;color:#8EC0E4;font-size:1.5em;font-weight: bold;">Git is a Distributed Version Control System.</p><h3 id="BUT-Why-Git-is-a-Distributed-Version-Control-System"><a href="#BUT-Why-Git-is-a-Distributed-Version-Control-System" class="headerlink" title="BUT :  Why Git is a Distributed Version Control System ?"></a>BUT :  Why Git is a Distributed Version Control System ?</h3><p>所谓的Git是一个分布式版本控制系统（DVCS）这句话究竟如何理解？首先先理解何为版本控制系统VCS？</p><h4 id="何为版本控制系统VCS？"><a href="#何为版本控制系统VCS？" class="headerlink" title="何为版本控制系统VCS？"></a>何为版本控制系统VCS？</h4><p><strong>版本控制、主动提交、中央仓库</strong>这三个要素，共同构成了版本控制系统VCS的核心；开发团队中的每个人向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统。</p><p><strong>版本控制</strong>是最基本的功能：形象地来理解，对于我们熟知的<code>command/control + z</code>撤销操作可以视作最简化的版本控制模型。操作一次回到上一次操作，两次就是回到上两次操作。同样的在写程序的时候我们也会经常碰到写错或者想回退的情况，所谓的版本控制就是在文件的修改过程中保留修改历史，让我们可以方便地撤销之前对于文件的修改操作。</p><p><strong>主动提交</strong>：由于代码修改的生命周期相比文本编辑非常长，如果采用每次自动保存的形式来保存修改历史，将会导致改动的历史频繁且无章可循。VCS采用主动提交的方式来将改动记录到版本历史中，并附带信息更方便查找以及其他操作。</p><p><strong>中央仓库</strong>：代码更多的是多人共同开发，需要一个中央仓库作为代码的存储中心以便所有人都可以看到以及下载他人的改动。</p><h4 id="何为分布式版本控制系统DVCS"><a href="#何为分布式版本控制系统DVCS" class="headerlink" title="何为分布式版本控制系统DVCS?"></a>何为分布式版本控制系统DVCS?</h4><p><strong>中央式VCS的工作模式</strong>：在公司服务器上创建一个中央仓库，我把最初写的代码框架提交到中央仓库（直接交互），我的队友们也要加入开发，就从中央仓库拉取到我的初始代码，此时开始我们并行开发。之后，每个人开发完一个功能就把新代码提交到中央仓库。每当提交新代码之后，其他人都可以去中央仓库拉取最新的代码。</p><p><strong>DVCS工作模式</strong>：我有一个初始代码框架并提交到了本地仓库、然后我在服务器上创建一个中央仓库并把之前的提交从本地仓库push到服务器的中央仓库，其他队友要进来开发首先把中央仓库的所有内容clone到本地（此时他们就拥有了本地仓库，开始并行开发）。之后每个人独立开发不同功能，开发中的每一步都可以提交到本地仓库，某个功能开发好了可以把这个功能所有的提交从本地仓库推送到中央仓库。每当有人有新的push，其他人都可以同步到自己仓库并和本地代码合并。</p><p>在VCS上增加了distributed的概念。</p><p>分布式 VCS (Distributed VCS / DVCS)和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库:团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史， 而无需联网和中央仓库交互——当然，取而代之的，你需要和本地仓库交互。中央式 VCS 的中央仓库有两个主要功能:保存版本历史、同步团队代码。而在分布式 VCS 中，保存版本历史的工作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步 团队代码这一个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。</p><p>分布式 VCS可粗略理解为代码提交上传分开的中央式 VCS，增加本地仓库的交互。减轻中央仓库功能压力使其专注于同步团队代码，同时也让每个人可以在个人环境中提交和查看历史。其优势在于：1、大多数的操作可以在本地进行，所以速度更快，而且无需联网。2、由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，而不是一个提交包含很多代码，难以 review 也难以回溯。缺点在于：由于每个机器都有完整的本地仓库，所以本地占用的存储比中央式 VCS 要高。初次获取项目(Git 术语:clone)的时候会比较耗时。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
